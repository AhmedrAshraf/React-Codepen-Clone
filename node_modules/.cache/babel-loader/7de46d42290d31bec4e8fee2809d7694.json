{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var htmlConfig = {\n    autoSelfClosers: {\n      'area': true,\n      'base': true,\n      'br': true,\n      'col': true,\n      'command': true,\n      'embed': true,\n      'frame': true,\n      'hr': true,\n      'img': true,\n      'input': true,\n      'keygen': true,\n      'link': true,\n      'meta': true,\n      'param': true,\n      'source': true,\n      'track': true,\n      'wbr': true,\n      'menuitem': true\n    },\n    implicitlyClosed: {\n      'dd': true,\n      'li': true,\n      'optgroup': true,\n      'option': true,\n      'p': true,\n      'rp': true,\n      'rt': true,\n      'tbody': true,\n      'td': true,\n      'tfoot': true,\n      'th': true,\n      'tr': true\n    },\n    contextGrabbers: {\n      'dd': {\n        'dd': true,\n        'dt': true\n      },\n      'dt': {\n        'dd': true,\n        'dt': true\n      },\n      'li': {\n        'li': true\n      },\n      'option': {\n        'option': true,\n        'optgroup': true\n      },\n      'optgroup': {\n        'optgroup': true\n      },\n      'p': {\n        'address': true,\n        'article': true,\n        'aside': true,\n        'blockquote': true,\n        'dir': true,\n        'div': true,\n        'dl': true,\n        'fieldset': true,\n        'footer': true,\n        'form': true,\n        'h1': true,\n        'h2': true,\n        'h3': true,\n        'h4': true,\n        'h5': true,\n        'h6': true,\n        'header': true,\n        'hgroup': true,\n        'hr': true,\n        'menu': true,\n        'nav': true,\n        'ol': true,\n        'p': true,\n        'pre': true,\n        'section': true,\n        'table': true,\n        'ul': true\n      },\n      'rp': {\n        'rp': true,\n        'rt': true\n      },\n      'rt': {\n        'rp': true,\n        'rt': true\n      },\n      'tbody': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'td': {\n        'td': true,\n        'th': true\n      },\n      'tfoot': {\n        'tbody': true\n      },\n      'th': {\n        'td': true,\n        'th': true\n      },\n      'thead': {\n        'tbody': true,\n        'tfoot': true\n      },\n      'tr': {\n        'tr': true\n      }\n    },\n    doNotIndent: {\n      \"pre\": true\n    },\n    allowUnquoted: true,\n    allowMissing: true,\n    caseFold: true\n  };\n  var xmlConfig = {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false,\n    allowMissingTagName: false,\n    caseFold: false\n  };\n  CodeMirror.defineMode(\"xml\", function (editorConf, config_) {\n    var indentUnit = editorConf.indentUnit;\n    var config = {};\n    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;\n\n    for (var prop in defaults) {\n      config[prop] = defaults[prop];\n    }\n\n    for (var prop in config_) {\n      config[prop] = config_[prop];\n    } // Return variables for tokenizers\n\n\n    var type, setStyle;\n\n    function inText(stream, state) {\n      function chain(parser) {\n        state.tokenize = parser;\n        return parser(stream, state);\n      }\n\n      var ch = stream.next();\n\n      if (ch == \"<\") {\n        if (stream.eat(\"!\")) {\n          if (stream.eat(\"[\")) {\n            if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));else return null;\n          } else if (stream.match(\"--\")) {\n            return chain(inBlock(\"comment\", \"-->\"));\n          } else if (stream.match(\"DOCTYPE\", true, true)) {\n            stream.eatWhile(/[\\w\\._\\-]/);\n            return chain(doctype(1));\n          } else {\n            return null;\n          }\n        } else if (stream.eat(\"?\")) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          state.tokenize = inBlock(\"meta\", \"?>\");\n          return \"meta\";\n        } else {\n          type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n          state.tokenize = inTag;\n          return \"tag bracket\";\n        }\n      } else if (ch == \"&\") {\n        var ok;\n\n        if (stream.eat(\"#\")) {\n          if (stream.eat(\"x\")) {\n            ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n          } else {\n            ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n          }\n        } else {\n          ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n        }\n\n        return ok ? \"atom\" : \"error\";\n      } else {\n        stream.eatWhile(/[^&<]/);\n        return null;\n      }\n    }\n\n    inText.isInText = true;\n\n    function inTag(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \">\" || ch == \"/\" && stream.eat(\">\")) {\n        state.tokenize = inText;\n        type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n        return \"tag bracket\";\n      } else if (ch == \"=\") {\n        type = \"equals\";\n        return null;\n      } else if (ch == \"<\") {\n        state.tokenize = inText;\n        state.state = baseState;\n        state.tagName = state.tagStart = null;\n        var next = state.tokenize(stream, state);\n        return next ? next + \" tag error\" : \"tag error\";\n      } else if (/[\\'\\\"]/.test(ch)) {\n        state.tokenize = inAttribute(ch);\n        state.stringStartCol = stream.column();\n        return state.tokenize(stream, state);\n      } else {\n        stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n        return \"word\";\n      }\n    }\n\n    function inAttribute(quote) {\n      var closure = function closure(stream, state) {\n        while (!stream.eol()) {\n          if (stream.next() == quote) {\n            state.tokenize = inTag;\n            break;\n          }\n        }\n\n        return \"string\";\n      };\n\n      closure.isInAttribute = true;\n      return closure;\n    }\n\n    function inBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = inText;\n            break;\n          }\n\n          stream.next();\n        }\n\n        return style;\n      };\n    }\n\n    function doctype(depth) {\n      return function (stream, state) {\n        var ch;\n\n        while ((ch = stream.next()) != null) {\n          if (ch == \"<\") {\n            state.tokenize = doctype(depth + 1);\n            return state.tokenize(stream, state);\n          } else if (ch == \">\") {\n            if (depth == 1) {\n              state.tokenize = inText;\n              break;\n            } else {\n              state.tokenize = doctype(depth - 1);\n              return state.tokenize(stream, state);\n            }\n          }\n        }\n\n        return \"meta\";\n      };\n    }\n\n    function Context(state, tagName, startOfLine) {\n      this.prev = state.context;\n      this.tagName = tagName;\n      this.indent = state.indented;\n      this.startOfLine = startOfLine;\n      if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;\n    }\n\n    function popContext(state) {\n      if (state.context) state.context = state.context.prev;\n    }\n\n    function maybePopContext(state, nextTagName) {\n      var parentTagName;\n\n      while (true) {\n        if (!state.context) {\n          return;\n        }\n\n        parentTagName = state.context.tagName;\n\n        if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n          return;\n        }\n\n        popContext(state);\n      }\n    }\n\n    function baseState(type, stream, state) {\n      if (type == \"openTag\") {\n        state.tagStart = stream.column();\n        return tagNameState;\n      } else if (type == \"closeTag\") {\n        return closeTagNameState;\n      } else {\n        return baseState;\n      }\n    }\n\n    function tagNameState(type, stream, state) {\n      if (type == \"word\") {\n        state.tagName = stream.current();\n        setStyle = \"tag\";\n        return attrState;\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return attrState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return tagNameState;\n      }\n    }\n\n    function closeTagNameState(type, stream, state) {\n      if (type == \"word\") {\n        var tagName = stream.current();\n        if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);\n\n        if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n          setStyle = \"tag\";\n          return closeState;\n        } else {\n          setStyle = \"tag error\";\n          return closeStateErr;\n        }\n      } else if (config.allowMissingTagName && type == \"endTag\") {\n        setStyle = \"tag bracket\";\n        return closeState(type, stream, state);\n      } else {\n        setStyle = \"error\";\n        return closeStateErr;\n      }\n    }\n\n    function closeState(type, _stream, state) {\n      if (type != \"endTag\") {\n        setStyle = \"error\";\n        return closeState;\n      }\n\n      popContext(state);\n      return baseState;\n    }\n\n    function closeStateErr(type, stream, state) {\n      setStyle = \"error\";\n      return closeState(type, stream, state);\n    }\n\n    function attrState(type, _stream, state) {\n      if (type == \"word\") {\n        setStyle = \"attribute\";\n        return attrEqState;\n      } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n        var tagName = state.tagName,\n            tagStart = state.tagStart;\n        state.tagName = state.tagStart = null;\n\n        if (type == \"selfcloseTag\" || config.autoSelfClosers.hasOwnProperty(tagName)) {\n          maybePopContext(state, tagName);\n        } else {\n          maybePopContext(state, tagName);\n          state.context = new Context(state, tagName, tagStart == state.indented);\n        }\n\n        return baseState;\n      }\n\n      setStyle = \"error\";\n      return attrState;\n    }\n\n    function attrEqState(type, stream, state) {\n      if (type == \"equals\") return attrValueState;\n      if (!config.allowMissing) setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n\n    function attrValueState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n\n      if (type == \"word\" && config.allowUnquoted) {\n        setStyle = \"string\";\n        return attrState;\n      }\n\n      setStyle = \"error\";\n      return attrState(type, stream, state);\n    }\n\n    function attrContinuedState(type, stream, state) {\n      if (type == \"string\") return attrContinuedState;\n      return attrState(type, stream, state);\n    }\n\n    return {\n      startState: function startState(baseIndent) {\n        var state = {\n          tokenize: inText,\n          state: baseState,\n          indented: baseIndent || 0,\n          tagName: null,\n          tagStart: null,\n          context: null\n        };\n        if (baseIndent != null) state.baseIndent = baseIndent;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (!state.tagName && stream.sol()) state.indented = stream.indentation();\n        if (stream.eatSpace()) return null;\n        type = null;\n        var style = state.tokenize(stream, state);\n\n        if ((style || type) && style != \"comment\") {\n          setStyle = null;\n          state.state = state.state(type || style, stream, state);\n          if (setStyle) style = setStyle == \"error\" ? style + \" error\" : setStyle;\n        }\n\n        return style;\n      },\n      indent: function indent(state, textAfter, fullLine) {\n        var context = state.context; // Indent multi-line strings (e.g. css).\n\n        if (state.tokenize.isInAttribute) {\n          if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;\n        }\n\n        if (context && context.noIndent) return CodeMirror.Pass;\n        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0; // Indent the starts of attribute names.\n\n        if (state.tagName) {\n          if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n        }\n\n        if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n        var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n\n        if (tagAfter && tagAfter[1]) {\n          // Closing tag spotted\n          while (context) {\n            if (context.tagName == tagAfter[2]) {\n              context = context.prev;\n              break;\n            } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n              context = context.prev;\n            } else {\n              break;\n            }\n          }\n        } else if (tagAfter) {\n          // Opening tag spotted\n          while (context) {\n            var grabbers = config.contextGrabbers[context.tagName];\n            if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;\n          }\n        }\n\n        while (context && context.prev && !context.startOfLine) {\n          context = context.prev;\n        }\n\n        if (context) return context.indent + indentUnit;else return state.baseIndent || 0;\n      },\n      electricInput: /<\\/[\\s\\w:]+>$/,\n      blockCommentStart: \"<!--\",\n      blockCommentEnd: \"-->\",\n      configuration: config.htmlMode ? \"html\" : \"xml\",\n      helperType: config.htmlMode ? \"html\" : \"xml\",\n      skipAttribute: function skipAttribute(state) {\n        if (state.state == attrValueState) state.state = attrState;\n      },\n      xmlCurrentTag: function xmlCurrentTag(state) {\n        return state.tagName ? {\n          name: state.tagName,\n          close: state.type == \"closeTag\"\n        } : null;\n      },\n      xmlCurrentContext: function xmlCurrentContext(state) {\n        var context = [];\n\n        for (var cx = state.context; cx; cx = cx.prev) {\n          if (cx.tagName) context.push(cx.tagName);\n        }\n\n        return context.reverse();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/xml\", \"xml\");\n  CodeMirror.defineMIME(\"application/xml\", \"xml\");\n  if (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\")) CodeMirror.defineMIME(\"text/html\", {\n    name: \"xml\",\n    htmlMode: true\n  });\n});","map":{"version":3,"names":["mod","exports","module","require","define","amd","CodeMirror","htmlConfig","autoSelfClosers","implicitlyClosed","contextGrabbers","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","allowMissingTagName","defineMode","editorConf","config_","indentUnit","config","defaults","htmlMode","prop","type","setStyle","inText","stream","state","chain","parser","tokenize","ch","next","eat","match","inBlock","eatWhile","doctype","inTag","ok","isInText","baseState","tagName","tagStart","test","inAttribute","stringStartCol","column","quote","closure","eol","isInAttribute","style","terminator","depth","Context","startOfLine","prev","context","indent","indented","hasOwnProperty","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","current","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","startState","baseIndent","token","sol","indentation","eatSpace","textAfter","fullLine","Pass","length","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","exec","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","xmlCurrentTag","name","close","xmlCurrentContext","cx","push","reverse","defineMIME","mimeModes"],"sources":["/Users/ahmed/Desktop/Projects/Codepen-Clone-main/node_modules/codemirror/mode/xml/xml.js"],"sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        if (cx.tagName) context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}